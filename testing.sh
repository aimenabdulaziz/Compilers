#!/bin/bash

# ---------------------------------------------------------------------------
# Testing Script for C Compiler
# 
# This script is designed to test the functionality of a C compiler. The 
# compiler is separated into three main components: the frontend, the 
# optimization, and the backend, each of which is built and tested separately.
#
# The script performs the following steps for each .c file found in the
# specified test directory:
# 
#   1. Runs the frontend on the .c file.
#   2. Optimizes the intermediate representation (IR) generated by the frontend.
#   3. Generates x86 assembly code from the optimized IR.
#   4. Compiles the generated assembly code and a main.c file into an executable.
#   5. Compiles the original .c file and the main.c file into another executable
#      which will serve as the expected output.
#   6. Runs both executables, captures their output, and compares the two.
#      If they are not the same, the test is considered failed.
#   7. Cleans up any temporary files created during the process.
# 
# Color-coded feedback is provided for each test. Successful tests are 
# indicated in green, and failed tests are indicated in red.
# 
# Author: Aimen Abdulaziz
# Date: Spring 2023
# ---------------------------------------------------------------------------


# Set the directory containing the test files
dir=tests/backend

# Define ANSI escape codes for colors
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Build all executables
build_executables() {
    (cd frontend && make)
    (cd optimization && make)
    (cd backend && make)
}

# Check if an executable returns 0 when run with a file
check_executable() {
    local executable="$1"
    local file="$2"
    local base="$3"

    $executable "$file"
    if [ $? -ne 0 ]; then
        echo -e "${RED}Test failed: $base.c${NC}"
        return 1
    fi
    return 0
}

# Compare the output of two strings and print the result
compare_outputs() {
    local expected="$1"
    local output="$2"
    local base="$3"

    if [ "$output" != "$expected" ]; then
        echo -e "${RED}Test failed: $base${NC}"
        echo -e "${RED}Expected:${NC}"
        echo "$expected"
        echo -e "${RED}Got:${NC}"
        echo "$output"
    else
        echo -e "${GREEN}Test passed: $base${NC}"
    fi
}

# Clean up temporary files
cleanup() {
    local base="$1"
    rm -f $dir/"$base"_manual.ll $dir/"$base"_manual_opt.ll $dir/"$base"_manual_opt.s "$dir"/"$base".expected "$dir"/"$base".out
}

# Build all executables
build_executables

# Loop over each test file in the directory
for file in `ls "$dir"/*.c | grep -v main.c`; do
    # Exit if main.c is not found
    if [ ! -f "$dir"/main.c ]; then
        echo "main.c not found"
        exit 1
    fi

    # Extract the base name of the file without the .c extension
    base=$(basename "$file" .c)

    echo "Testing $file"

    # Run the frontend and check for errors
    if ! check_executable frontend/frontend "$file" "$base"; then continue; fi
    echo "Result: Frontend successful"

    # Optimize the IR generated by the frontend and check for errors
    if ! check_executable optimization/optimizer $dir/"$base"_manual.ll "$base"; then continue; fi
    echo "Result: Optimization successful"

    # Generate x86 assembly code from the LLVM IR code using the codegen executable and check for errors
    if ! check_executable backend/codegen $dir/"$base"_manual_opt.ll "$base"; then continue; fi
    echo "Result: Assembly code generation successful"

    # Compile main.c and the generated assembly code into an executable
    clang $dir/main.c $dir/"$base"_manual_opt.s -m32 -o $dir/"$base".out

    # Compile main.c and file into an executable. This will be used as the expected output.
    clang $dir/main.c "$file" -o $dir/"$base".expected

    # Check if the test file requires input
    if grep -q "= *read *(" "$file"; then
        # Generate a random integer between 1 and 1000
        input=$(shuf -i 1-1000 -n 1)

        echo "Test "$base" with input "$input""

        # Pass the random integer as input to the expected executable and capture the output
        expected=$(echo "$input" | "./$dir/$base.expected")

        # Run the executable with the random integer as input and capture the output
        output=$(echo "$input" | "./$dir/$base.out")
    else
        # Read the expected output from a file
        expected=$("./$dir/$base.expected")

        # Run the executable and capture the output
        output=$("./$dir/$base.out")
    fi

    # Compare the output to the expected output and print the result
    compare_outputs "$expected" "$output" "$base"
    
    # Clean up temporary files
    cleanup "$base"

done