# MiniC Frontend Implementation Spec
## Aimen Abdulaziz, Spring 2023

### Incorporated Modules

Several modules have been incorporated to ensure the correct analysis and interpretation of the MiniC programming language. These modules are responsible for different aspects of the process, including parsing, tokenization, and semantic analysis. Here's a brief explanation of each module:

- `Lexical Analyzer` - The lexical analyzer module is responsible for scanning and tokenizing the input source code. It reads the input text and breaks it down into a sequence of tokens that represent keywords, operators, identifiers, literals, and other elements of the MiniC language. These tokens are then passed to the parser for further analysis.
_ `Parser` - The parser module contains the grammar rules and actions for parsing the MiniC. It takes the tokens generated by the lexical analyzer and constructs an AST based on the grammar rules defined for the language. If the input program follows the correct syntax, the parser generates an AST, which can then be passed to the semantic_analysis module for further analysis.
- `ast` - This module defines the data structures and functions for constructing and manipulating the Abstract Syntax Tree (AST). The AST represents the structure and semantics of a MiniC program in a tree-like format, making it easier for other modules to traverse and analyze the program.
- `semantic_analysis` - This module is responsible for analyzing the AST to ensure that all variables are declared before they are used. It takes an AST node as input and performs a series of traversals and checks to populate symbol tables and detect undeclared variables. If any undeclared variables are found, the module reports an error and the analysis is considered unsuccessful.

## Data Structures 

- `ast` module for Abstract Syntax Tree (AST) representation
- Symbol tables (vector of set of strings) to keep track of variable declarations for semantic Analysis. Each symbol table is represented as a `std::set` of `std::string`. This choice ensures that the symbol table contains unique variable names and provides efficient lookup. The stack of symbol tables is represented as a `std::vector`.

## Control flow

The MiniC Compiler is implemented in multiple files including `miniC_main.c`, `miniC.y`, `miniC.l`, `ast.c`, and `semantic_analysis.c`.

## Function prototypes

### miniC_main

The main function initializes the parser and the lexer, then calls the `yyparse` function to start the parsing process. After successful parsing, it constructs an AST and performs semantic analysis on the root of the AST node.
```c
int main(int argc, char* argv[]);
void yyerror(const char *);
```

### semantic_analysis
```c
int semantic_analysis(ast_node_t *node);
static bool traverse(astNode *node, vector<set<string>> *symbolTables);
static bool traverseStmt(astStmt *stmt, vector<set<string>> *symbolTables);
```

### ast
```c
astNode* createProg(astNode* extern1, astNode* extern2, astNode* func);
astNode* createFunc(const char* name, astNode* param, astNode* body);
astNode* createExtern(const char *name);
astNode* createVar(const char *name);
astNode* createCnst(int value);
astNode* createRExpr(astNode* lhs, astNode* rhs, rop_type op);
astNode* createBExpr(astNode* lhs, astNode* rhs, op_type op);
astNode* createUExpr(astNode* expr, op_type op);
astNode* createCall(const char *name, astNode *param=NULL);
astNode* createRet(astNode* expr);
astNode* createBlock(vector<astNode*> *stmt_list);
astNode* createWhile(astNode* cond, astNode* body);
astNode* createIf(astNode* cond, astNode* if_body, astNode* else_body=NULL);
astNode* createDecl(const char* decl);
astNode* createAsgn(astNode* lhs, astNode* rhs);
void freeProg(astNode*);
void freeFunc(astNode*);
void freeExtern(astNode*);
void freeVar(astNode*);
void freeCnst(astNode*);
void freeRExpr(astNode*);
void freeBExpr(astNode*);
void freeUExpr(astNode*);
void freeCall(astNode*);
void freeRet(astNode*);
void freeBlock(astNode*);
void freeWhile(astNode*);
void freeIf(astNode*);
void freeDecl(astNode*);
void freeAsgn(astNode*);
void freeNode(astNode*);
void freeStmt(astNode*);
void printNode(astNode*, int indent=0);
void printStmt(astStmt*, int indent=0);
```

### Files

- `ast.c` - Contains the functions for constructing and manipulating the Abstract Syntax Tree (AST).
- `ast.h` - Header file containing the data structures and function prototypes related to the AST.
- `ast_test.c` - Hardcoded test cases for the ast module.
- `IMPLEMENTATION.md` - Describes the implementation details, control flow, data structures, and function prototypes.
- `Makefile`- Defines the compilation procedure and dependencies for the project.
- `semantic_analysis.c` - Implements the functions required for performing semantic analysis on the AST.
- `semantic_analysis.h` - Header file for the semantic_analysis module.
- `miniC.l` - Lexical analyzer (lexer) definition file using Flex for tokenizing the input source code.
- `miniC.y` - Parser definition file using Bison for parsing MiniC programs and constructing the AST.
- `miniC_main.c` - Main entry point of the MiniC Compiler, responsible for initializing the parser and lexer, constructing AST, and invoking semantic analysis.
- `testing.sh` - Shell script to automate testing by running multiple test cases for lexer, parser, and semantic analysis.
- `lex_yacc_tests/` - Directory containing test cases for the lexer (Flex) and parser (Bison).
- `semantic_tests/` - Directory containing test cases for the semantic analysis.